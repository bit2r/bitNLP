% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nlp.R
\name{filter_text}
\alias{filter_text}
\title{Filter data based on string matches of text data}
\usage{
filter_text(
  doc,
  as_logical = TRUE,
  chunk = round(length(if (tibble::is_tibble(doc)) dplyr::pull(doc) else doc)/mc.cores),
  mc.cores = parallel::detectCores(),
  verbos = TRUE
)
}
\arguments{
\item{doc}{character. 문자열 필터링을 수행할 문자열 벡터}

\item{as_logical}{logical. 반환값을 논리벡터로 반환할지의 여부. 
기본값 TRUE이면 추출한 대상을 의미하는 논리값을 반환하고, 
FALSE이면 대상을 추출한 문자열 벡터를 반환. 
tidytext 패키지를 사용할 경우에는 기본값인 TRUE를 사용하면 됨}

\item{chunk}{integer. 병렬 작업 수행 시 처리 단위인 chunk}

\item{mc.cores}{integer. 병렬 작업 수행 시 사용할 코어의 개수}

\item{verbos}{logical. 메타의 Rule 당 처리된 건수를 화면에 출력할 지의 여부}
}
\value{
character. 문자열 필터링이 수행된 문자열 벡터.
}
\description{
텍스트 데이터의 전처리 과정 중 패턴 일치되는 문자열이 있는
데이터를 취하거나 제거한다.
}
\details{
Windows 운영체제에서는 병력작업이 지원되지 않기 때문에, 사용자의 설정과는 무관하게 mc.cores의 값이 1로 적용됩니다.
}
\examples{
\donttest{
##======================================================
## 문자열 매치 데이터 필터링
##======================================================

# 매치 데이터 필터링 메타 신규 등록
meta_path <- system.file("meta", package = "bitNLP")
fname <- glue::glue("{meta_path}/preparation_filter.csv")
set_meta("filter", fname, fileEncoding = "utf8")

# 등록된 필터링 룰 확인하기
get_meta("filter")

doc_content <- buzz[, "CONTENT"]

# 필터링, verbos = FALSE, chunk = 200
doc_after_logical <- filter_text(doc_content, verbos = FALSE, chunk = 200)

# 필터링, as_logical = FALSE,  mc.cores = 8, 
doc_after_character <- filter_text(doc_content, as_logical = FALSE, mc.cores = 8)

# 필터링 전/후 비교
NROW(doc_content)
sum(doc_after_logical)
NROW(doc_after_character)

# tidyverse(혹은 tidytext)와의 협업
library(dplyr)
buzz \%>\% 
  filter(filter_text(CONTENT, verbos = FALSE)) \%>\% 
  select(KEYWORD, SRC, CONTENT)
}

}
